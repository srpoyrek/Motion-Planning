InitializationObjects
In[1]:= (* Returns a Nested list of pair of points representing each line in polygon*)
lineList[list_]:=Partition[Append[list,First[list]],2,1]; 
In[8]:= (*Retruns True if refelx else false*)
reflex[{x1_,y1_},{x2_,y2_},{x3_,y3_}]:=Chop[Det[(1	x1	y1
1	x2	y2
1	x3	y3

)]>  0]
In[3]:= (* Discretizes a line, returns points on a line which are at equidistant from each other.*)
discretizeLine[{{x1_,y1_},{x2_,y2_}},step_]:=
({(x1+(x2-x1)*#),(y1+(y2-y1)*#)})&/@Range[0,1,step]
In[4]:= (* Discretizes a polygon using the discretizeLine function*)
discretizePoly[poly_,step_]:=
Append[Flatten[discretizeLine[#,step][[1;;(1/step)-1]]&/@lineList[poly],1],First@poly]
In[5]:= (*Returns a Normal Vector for a line between two points*)
normalVector[{{x2_,y2_},{x1_,y1_}}]:=Normalize[{(-y2+y1),x2-x1} ]
In[6]:= (*Returns a Vector for a line between two points*)
vector[{{x2_,y2_},{x1_,y1_}}]:={x2-x1,y2-y1}
(*Refrence:- https://mathematica.stackexchange.com/questions/18647/how-to-check-if-an-expression-is-a-real-valued-number*)
realQrm[_Real|_Integer|_Rational]:=True
realQrm[_]:=False
Demo code
In[172]:= Manipulate[
Module[{oldpts={},roboconvex,oboconvex,robot,obstacle,rc,oc,robotNormal,obstacleNormal,robotArrows,obstacleArrows,robotSubscript,obstacleSubscript,robotAssignedNormal,obstacleAssignedNormal,orderOfNormals,minkowskiPoints,shiftedMink,minklinelist,minkrobotlinelist={},minkObstlinelist={},sortedArrows,sortedNormals,robotlabel,obstaclelabel,sortedNormalRobot,sortedNormalObstacle,discretPolygon,sortedVectors,pos,prev,minkowskiPointswithSide,shiftedMinkwithSide,minkowskiSidesNormalArrows,shiftedMinkLineList,roboPosMink,obosPosMink,minkowskiRobotSidesLabels,minkowskiObstacleSidesLabels,orderOfNormalsKeys},

(*constrain vertices of robot and obstacle*)
If[pts!= oldpts,oldpts=pts;
Table[If[pts[[i]][[1]]<1.34704,pts[[i]][[1]]=1.34704],{i,1,m,1}];
Table[If[pts[[i]][[1]]>-1.34704,pts[[i]][[1]]=-1.34704],{i,6,n+5,1}];
];
(*Get Convex Polygons for robot & obstacles*)
roboconvex =If[m>=3,Reverse@(#["Coordinates"][[#["BoundaryVertices"][[1]]]]&@ConvexHullMesh[pts[[1;;m]]]),
pts[[1;;m+1]]];
(*Print@roboconvex;*)
oboconvex =If[n>= 3,Reverse@(#["Coordinates"][[#["BoundaryVertices"][[1]]]]&@ConvexHullMesh[pts[[6;;n+5]]]),pts[[6;;n+6]]];
rl=Length@roboconvex-1;
ol=Length@oboconvex-1;
robot=roboconvex[[1;;rl]];
obstacle=oboconvex[[1;;ol]];

(*Get the Centroids robot & obstacle Polygons*)
rc=Mean@robot;
oc=Mean@obstacle;

(*Correct the direction for triangle when it is flipped*)
If[m==3, 
If[!realQrm@(ArcCos@VectorAngle[vector[{rc,Median[robot[[1;;2]]]}],-normalVector[robot[[1;;2]]]]),robot=Reverse@robot];];
If[n==3,
If[!realQrm@(ArcCos@VectorAngle[vector[{oc,Median[obstacle[[1;;2]]]}],-normalVector[obstacle[[1;;2]]]]),obstacle=Reverse@obstacle];];

(*Get the Robot and Obstacle Normals*)
robotNormal = {If[rl>=2,(-normalVector[#]),{0,0}],If[rl>=2,-vector[#],{0,0}],"α",#}&/@(lineList@robot);

 (* Robot Normals are in inward direction*)
obstacleNormal={If[ol>=2,normalVector[#],{0,0}],If[ol>=2,vector[#],{0,0}],"β",#}&/@(lineList@obstacle);(* Obstacle Normals are in outward direction*)

(*Make Arrows on inside the polygons*) (*Retouching the code needed*)
robotArrows=Arrow[{Median[#[[4]]],0.45#[[1]]+Median[#[[4]]]}]&/@robotNormal; 
obstacleArrows = Arrow[{Median[#[[4]]],0.45#[[1]]+Median[#[[4]]]}]&/@obstacleNormal;	

(*Create Sub script*)
robotSubscript=Cases[Range[1,Length[robotNormal]],t:_:>Subscript[α, t]];
obstacleSubscript=Cases[Range[1,Length[obstacleNormal]],t:_:>Subscript[β, t]];

(*Assign the Edges of robot with α and obstacle as /[Beta]*)
robotAssignedNormal =AssociationThread[robotSubscript-> robotNormal];
obstacleAssignedNormal =AssociationThread[obstacleSubscript-> obstacleNormal];

(*Merge the Normals & add the angles in the value list and Sort the Nested List based on Angles*)
orderOfNormals =Sort[{If[!(#[[1]][[1]]==0&&#[[1]][[2]]==0) ,ArcTan[#[[1]][[1]],#[[1]][[2]]],None],#[[1]],#[[2]],#[[3]],#[[4]]}&/@Join [robotAssignedNormal,obstacleAssignedNormal],#1[[1]]<#2[[1]]&];
sortedVectors=Values[orderOfNormals];

(*Get the Sequence position where α & β meet*)
pos=SequencePosition[sortedVectors[[;;,4]],{"α","β"}][[1,1]];
orderOfNormalsKeys=RotateLeft[Keys@orderOfNormals,pos];

(*Calculate the Prev Vaule based on the position*)
prev=rc+sortedVectors[[pos+1]][[5]][[1]] -sortedVectors[[pos]][[5]][[1]];

(*Get the Minkowski by adding the vectors in the sorted order*)
minkowskiPointswithSide=({Chop[prev=prev-#[[3]]],#[[4]]})&/@RotateLeft[sortedVectors,pos-1];
minkowskiPoints=(#[[1]]&/@minkowskiPointswithSide);

(*Get List of lines for robot & obstacle in the minkowski sum*)
shiftedMinkwithSide={(-oc+{2.298,-2.298}+#[[1]]),#[[2]]}&/@(minkowskiPointswithSide);
AppendTo[shiftedMinkwithSide,shiftedMinkwithSide[[1]]];

(*Shifted Minkowski Sum Points*)
shiftedMink=(#[[1]]&/@shiftedMinkwithSide);

(*Get robot and obstacle respective side from minkowski Region*)
Table[If[shiftedMinkwithSide[[i]][[2]]=="α",AppendTo[minkrobotlinelist,{shiftedMinkwithSide[[i-1]][[1]],shiftedMinkwithSide[[i]][[1]]}],AppendTo[minkObstlinelist,{shiftedMinkwithSide[[i-1]][[1]],shiftedMinkwithSide[[i]][[1]]}]],{i,2,Length@shiftedMinkwithSide,1}];

(*Make Arrows*) 
sortedArrows=Arrow[{{-2.3 ,-1.5},{-2.3,-1.5}+#[[2]]}]&/@Values[orderOfNormals]; (*Retouching the code needed*)

(*Draw Labels on Robot/Obstacle*)
robotlabel = If[rl>=2,Table[Text[Keys[robotAssignedNormal][[i]],(Median@robotAssignedNormal[[i]][[4]]-0.2robotAssignedNormal[[i]][[1]])],{i,1,Length[robotAssignedNormal],1}],{}];
obstaclelabel = If[ol>=2,Table[Text[Keys[obstacleAssignedNormal][[i]],(Median@obstacleAssignedNormal[[i]][[4]]-0.2obstacleAssignedNormal[[i]][[1]])],{i,1,Length[obstacleAssignedNormal],1}],{}];

(*Normal Labels on Sorted Normal Disk*)
sortedNormalRobot=If[rl>=2,Table[Text[Keys[robotAssignedNormal][[i]],{-2.3,-1.5}+1.2robotAssignedNormal[[i]][[1]]],{i,1,Length[robotAssignedNormal],1}],{}];
sortedNormalObstacle=If[ol>=2,Table[Text[Keys[obstacleAssignedNormal][[i]],{-2.3,-1.5}+1.2obstacleAssignedNormal[[i]][[1]]],{i,1,Length[obstacleAssignedNormal],1}],{}];

(*Minkowski Normals Arrows*)
minkowskiSidesNormalArrows= (Arrow[{Median[#],0.5normalVector@#+Median[#]}])&/@Join[minkrobotlinelist,minkObstlinelist];

(*Minkowski Robot/Obstacle Respective Side Normals Labels*)
shiftedMinkLineList=lineList@shiftedMink;
roboPosMink=(Flatten@(Position[orderOfNormalsKeys,Subscript[α, #]]&/@Range[1,rl]));
obosPosMink=(Flatten@(Position[orderOfNormalsKeys,Subscript[β, #]]&/@Range[1,ol]));
minkowskiRobotSidesLabels= If[rl>=2,(Text[orderOfNormalsKeys[[#]],-0.25(normalVector@shiftedMinkLineList[[#]])+Mean@shiftedMinkLineList[[#]]])&/@roboPosMink,{}];
minkowskiObstacleSidesLabels= If[ol>=2,(Text[orderOfNormalsKeys[[#]],-0.25(normalVector@shiftedMinkLineList[[#]])+Mean@shiftedMinkLineList[[#]]])&/@obosPosMink,{}];

(*Discretize the minkowski Polygon edges*)
discretPolygon =discretizePoly[minkowskiPoints,step];

Graphics[
{(*Boundary Graphics Object*)
{EdgeForm[Thin],White,Polygon@(7CirclePoints[4])}
,If[stableOrMove!="Move around Mikowski",
(*for "Stationary"*)
c=True;(*Enable the Locators*)
{(*Minkowski Sum Polygon Graphics Object*)
{{Opacity[0.5],LightGreen, Polygon@shiftedMink},{Blue,Line@minkrobotlinelist},{Red,Line@minkObstlinelist},{Black,Point@shiftedMink},{Black,Text["Minkowski Sum",{2.3,-4.75}]},If[a==True,{minkowskiSidesNormalArrows}],{Blue,minkowskiRobotSidesLabels},{Red,minkowskiObstacleSidesLabels}}
(*Obstacle Graphics Object*)
,{{EdgeForm[Red],LightRed, Polygon@obstacle},{Red,Point@pts[[6;;n+5]]},{Black,Point@obstacle},{Black,Point@oc},{If[a==True,{obstacleArrows}]},{Red,obstaclelabel},{Black,Text["Obstacle",{-2.3,0.8}]}}
(*Robot Graphics Object*)
,{{EdgeForm[Blue],LightBlue, Polygon@robot},{Blue,Point@pts[[1;;m]]},{Black,Point@robot},{Black,Point@rc},{If[a==True,{robotArrows}]},{Blue,robotlabel},{Black,Text["Robot",{2.3,0.8}]}}
(*Sorted Normals Graphic Object*)
,{{Black,sortedArrows},{EdgeForm[Thin],White,Disk[{-2.3,-1.5},{0.5,0.5}]},{Blue,sortedNormalRobot},{Red,sortedNormalObstacle},{Text["Sorted Normals",{-2.3,-3.2}]}}}
,(*for "Move around Mikowski"*)
c=False;(*Disable the Locators*)
{(*Minkowski Sum Polygon Graphics Object*)
{{EdgeForm[None],LightGreen,Opacity[0.5], Polygon@((-oc+#)&/@minkowskiPoints)}
,{Black,Point@((-oc+#)&/@minkowskiPoints)},{Blue,Line@(({-{2.298,-2.298}+#[[1]],-{2.298,-2.298}+#[[2]]})&/@minkrobotlinelist)},{Red,(Line@({-{2.298,-2.298}+#[[1]],-{2.298,-2.298}+#[[2]]})&/@(minkObstlinelist))},{ Black,Text["Minkowski Sum",{0,1.1}]}}
(*Obstacle Graphics Object*)
,{{EdgeForm[Red],LightRed, Polygon@((-oc+#)&/@obstacle)},{Black,Point@((-oc+#)&/@obstacle)},{Black,,Text["Obstacle",{0,0}]}}
(*Robot Graphics Object*)
,{{EdgeForm[Blue],Opacity[0.5],LightBlue,Polygon@((discretPolygon[[s]]-rc-oc+#)&/@robot)},{Black,Point@((discretPolygon[[s]]-rc-oc+#)&/@robot)},{Red,Point@(discretPolygon[[s]]-oc)},{Black,Text["Robot",discretPolygon[[s]]-oc+{0.2,0.2}]}}
}] }] ]

,{{stableOrMove,"Stationary","View"},{"Stationary","Move around Mikowski"}}
,{step,0.01,ControlType->None}
,{rl,ol,ControlType->None}
,{ol,ControlType->None}
,Dynamic@If[stableOrMove!="Move around Mikowski",
Row[{Control@{{a,True,"Normals"},{True,False}}
,Control@{{c,True,"Locators"},{True,False}}
,Control@{{m,5,"Robot Edges"},Range[1,5]}
,Control@{{n,5,"Obstacle Edges"},Range[1,5]}},"  "]
,Control@{{s,1,"Move"},1,((rl+ol)*(1/step))-(rl+ol-1),1,AnimationRunning->True,Appearance->"Open"}]
,{{pts,{{2.885,1.489},{3.249,2.60},{2.298,3.298},{1.348,2.607},{1.710,1.489},{-1.710,1.489},{-1.347,2.607},{-2.298,3.298},{-3.249,2.607},{-2.885,1.489}}},{-3.249,1.489},{3.249,3.298},
ControlType->Locator,Appearance->None,Enabled->c}
,AppearanceElements->{}
,PreserveImageOptions->True
]
Out[172]= Manipulate[Module[{oldpts$ = {}, roboconvex$, oboconvex$, robot$, obstacle$, 
    rc$, oc$, robotNormal$, obstacleNormal$, robotArrows$, obstacleArrows$, 
    robotSubscript$, obstacleSubscript$, robotAssignedNormal$, 
    obstacleAssignedNormal$, orderOfNormals$, minkowskiPoints$, shiftedMink$, 
    minklinelist$, minkrobotlinelist$ = {}, minkObstlinelist$ = {}, 
    sortedArrows$, sortedNormals$, robotlabel$, obstaclelabel$, 
    sortedNormalRobot$, sortedNormalObstacle$, discretPolygon$, 
    sortedVectors$, pos$, prev$, minkowskiPointswithSide$, 
    shiftedMinkwithSide$, minkowskiSidesNormalArrows$, shiftedMinkLineList$, 
    roboPosMink$, obosPosMink$, minkowskiRobotSidesLabels$, 
    minkowskiObstacleSidesLabels$, orderOfNormalsKeys$}, 
   If[pts != oldpts$, oldpts$ = pts; Table[If[pts[[i]][[1]] < 1.34704, 
        pts[[i]][[1]] = 1.34704], {i, 1, m, 1}]; 
      Table[If[pts[[i]][[1]] > -1.34704, pts[[i]][[1]] = -1.34704], 
       {i, 6, n + 5, 1}]; ]; roboconvex$ = 
     If[m >= 3, Reverse[(#1["Coordinates"][[#1["BoundaryVertices"][[1]]]] & )[
        ConvexHullMesh[pts[[1 ;; m]]]]], pts[[1 ;; m + 1]]]; 
    oboconvex$ = If[n >= 3, Reverse[
       (#1["Coordinates"][[#1["BoundaryVertices"][[1]]]] & )[
        ConvexHullMesh[pts[[6 ;; n + 5]]]]], pts[[6 ;; n + 6]]]; 
    rl = Length[roboconvex$] - 1; ol = Length[oboconvex$] - 1; 
    robot$ = roboconvex$[[1 ;; rl]]; obstacle$ = oboconvex$[[1 ;; ol]]; 
    rc$ = Mean[robot$]; oc$ = Mean[obstacle$]; 
    If[m == 3, 
     If[ !realQrm[ArcCos[VectorAngle[vector[{rc$, Median[robot$[[1 ;; 2]]]}], 
           -normalVector[robot$[[1 ;; 2]]]]]], robot$ = Reverse[robot$]]; ]; 
    If[n == 3, 
     If[ !realQrm[ArcCos[VectorAngle[vector[{oc$, Median[obstacle$[[1 ;; 
                2]]]}], -normalVector[obstacle$[[1 ;; 2]]]]]], 
       obstacle$ = Reverse[obstacle$]]; ]; robotNormal$ = 
     ({If[rl >= 2, -normalVector[#1], {0, 0}], If[rl >= 2, -vector[#1], 
         {0, 0}], "α", #1} & ) /@ lineList[robot$]; 
    obstacleNormal$ = ({If[ol >= 2, normalVector[#1], {0, 0}], 
        If[ol >= 2, vector[#1], {0, 0}], "β", #1} & ) /@ 
      lineList[obstacle$]; robotArrows$ = 
     (Arrow[{Median[#1[[4]]], 0.45*#1[[1]] + Median[#1[[4]]]}] & ) /@ 
      robotNormal$; obstacleArrows$ = 
     (Arrow[{Median[#1[[4]]], 0.45*#1[[1]] + Median[#1[[4]]]}] & ) /@ 
      obstacleNormal$; robotSubscript$ = 
     Cases[Range[1, Length[robotNormal$]], t_ :> Subscript[α, t]]; 
    obstacleSubscript$ = Cases[Range[1, Length[obstacleNormal$]], 
      t_ :> Subscript[β, t]]; robotAssignedNormal$ = 
     AssociationThread[robotSubscript$ -> robotNormal$]; 
    obstacleAssignedNormal$ = AssociationThread[obstacleSubscript$ -> 
       obstacleNormal$]; orderOfNormals$ = 
     Sort[({If[ !(#1[[1]][[1]] == 0 && #1[[1]][[2]] == 0), 
          ArcTan[#1[[1]][[1]], #1[[1]][[2]]], None], #1[[1]], #1[[2]], 
         #1[[3]], #1[[4]]} & ) /@ Join[robotAssignedNormal$, 
        obstacleAssignedNormal$], #1[[1]] < #2[[1]] & ]; 
    sortedVectors$ = Values[orderOfNormals$]; 
    pos$ = SequencePosition[sortedVectors$[[1 ;; All,4]], {"α", "β"}][[1,
      1]]; orderOfNormalsKeys$ = RotateLeft[Keys[orderOfNormals$], pos$]; 
    prev$ = rc$ + sortedVectors$[[pos$ + 1]][[5]][[1]] - 
      sortedVectors$[[pos$]][[5]][[1]]; minkowskiPointswithSide$ = 
     ({Chop[prev$ = prev$ - #1[[3]]], #1[[4]]} & ) /@ 
      RotateLeft[sortedVectors$, pos$ - 1]; minkowskiPoints$ = 
     (#1[[1]] & ) /@ minkowskiPointswithSide$; shiftedMinkwithSide$ = 
     ({-oc$ + {2.298, -2.298} + #1[[1]], #1[[2]]} & ) /@ 
      minkowskiPointswithSide$; AppendTo[shiftedMinkwithSide$, 
     shiftedMinkwithSide$[[1]]]; shiftedMink$ = (#1[[1]] & ) /@ 
      shiftedMinkwithSide$; Table[If[shiftedMinkwithSide$[[i]][[2]] == "α", 
      AppendTo[minkrobotlinelist$, {shiftedMinkwithSide$[[i - 1]][[1]], 
        shiftedMinkwithSide$[[i]][[1]]}], AppendTo[minkObstlinelist$, 
       {shiftedMinkwithSide$[[i - 1]][[1]], shiftedMinkwithSide$[[i]][[
         1]]}]], {i, 2, Length[shiftedMinkwithSide$], 1}]; 
    sortedArrows$ = (Arrow[{{-2.3, -1.5}, {-2.3, -1.5} + #1[[2]]}] & ) /@ 
      Values[orderOfNormals$]; robotlabel$ = 
     If[rl >= 2, Table[Text[Keys[robotAssignedNormal$][[i]], 
        Median[robotAssignedNormal$[[i]][[4]]] - 
         0.2*robotAssignedNormal$[[i]][[1]]], 
       {i, 1, Length[robotAssignedNormal$], 1}], {}]; 
    obstaclelabel$ = If[ol >= 2, Table[Text[Keys[obstacleAssignedNormal$][[
         i]], Median[obstacleAssignedNormal$[[i]][[4]]] - 
         0.2*obstacleAssignedNormal$[[i]][[1]]], 
       {i, 1, Length[obstacleAssignedNormal$], 1}], {}]; 
    sortedNormalRobot$ = If[rl >= 2, 
      Table[Text[Keys[robotAssignedNormal$][[i]], {-2.3, -1.5} + 
         1.2*robotAssignedNormal$[[i]][[1]]], 
       {i, 1, Length[robotAssignedNormal$], 1}], {}]; 
    sortedNormalObstacle$ = If[ol >= 2, 
      Table[Text[Keys[obstacleAssignedNormal$][[i]], {-2.3, -1.5} + 
         1.2*obstacleAssignedNormal$[[i]][[1]]], 
       {i, 1, Length[obstacleAssignedNormal$], 1}], {}]; 
    minkowskiSidesNormalArrows$ = 
     (Arrow[{Median[#1], 0.5*normalVector[#1] + Median[#1]}] & ) /@ 
      Join[minkrobotlinelist$, minkObstlinelist$]; 
    shiftedMinkLineList$ = lineList[shiftedMink$]; 
    roboPosMink$ = Flatten[(Position[orderOfNormalsKeys$, 
         Subscript[α, #1]] & ) /@ Range[1, rl]]; 
    obosPosMink$ = Flatten[(Position[orderOfNormalsKeys$, 
         Subscript[β, #1]] & ) /@ Range[1, ol]]; 
    minkowskiRobotSidesLabels$ = If[rl >= 2, 
      (Text[orderOfNormalsKeys$[[#1]], 
         -0.25*normalVector[shiftedMinkLineList$[[#1]]] + 
          Mean[shiftedMinkLineList$[[#1]]]] & ) /@ roboPosMink$, {}]; 
    minkowskiObstacleSidesLabels$ = If[ol >= 2, 
      (Text[orderOfNormalsKeys$[[#1]], 
         -0.25*normalVector[shiftedMinkLineList$[[#1]]] + 
          Mean[shiftedMinkLineList$[[#1]]]] & ) /@ obosPosMink$, {}]; 
    discretPolygon$ = discretizePoly[minkowskiPoints$, step]; 
    Graphics[{{EdgeForm[Thin], White, Polygon[7*CirclePoints[4]]}, 
      If[stableOrMove != "Move around Mikowski", 
       c = True; {{{Opacity[0.5], LightGreen, Polygon[shiftedMink$]}, 
          {Blue, Line[minkrobotlinelist$]}, {Red, Line[minkObstlinelist$]}, 
          {Black, Point[shiftedMink$]}, {Black, Text["Minkowski Sum", 
            {2.3, -4.75}]}, If[a == True, {minkowskiSidesNormalArrows$}], 
          {Blue, minkowskiRobotSidesLabels$}, 
          {Red, minkowskiObstacleSidesLabels$}}, 
         {{EdgeForm[Red], LightRed, Polygon[obstacle$]}, 
          {Red, Point[pts[[6 ;; n + 5]]]}, {Black, Point[obstacle$]}, 
          {Black, Point[oc$]}, {If[a == True, {obstacleArrows$}]}, 
          {Red, obstaclelabel$}, {Black, Text["Obstacle", {-2.3, 0.8}]}}, 
         {{EdgeForm[Blue], LightBlue, Polygon[robot$]}, 
          {Blue, Point[pts[[1 ;; m]]]}, {Black, Point[robot$]}, 
          {Black, Point[rc$]}, {If[a == True, {robotArrows$}]}, 
          {Blue, robotlabel$}, {Black, Text["Robot", {2.3, 0.8}]}}, 
         {{Black, sortedArrows$}, {EdgeForm[Thin], White, Disk[{-2.3, -1.5}, 
            {0.5, 0.5}]}, {Blue, sortedNormalRobot$}, 
          {Red, sortedNormalObstacle$}, {Text["Sorted Normals", 
            {-2.3, -3.2}]}}}, c = False; 
        {{{EdgeForm[None], LightGreen, Opacity[0.5], 
           Polygon[(-oc$ + #1 & ) /@ minkowskiPoints$]}, 
          {Black, Point[(-oc$ + #1 & ) /@ minkowskiPoints$]}, 
          {Blue, Line[({-{2.298, -2.298} + #1[[1]], -{2.298, -2.298} + 
                #1[[2]]} & ) /@ minkrobotlinelist$]}, 
          {Red, (Line[{-{2.298, -2.298} + #1[[1]], -{2.298, -2.298} + 
                #1[[2]]}] & ) /@ minkObstlinelist$}, 
          {Black, Text["Minkowski Sum", {0, 1.1}]}}, 
         {{EdgeForm[Red], LightRed, Polygon[(-oc$ + #1 & ) /@ obstacle$]}, 
          {Black, Point[(-oc$ + #1 & ) /@ obstacle$]}, {Black, Null, 
           Text["Obstacle", {0, 0}]}}, {{EdgeForm[Blue], Opacity[0.5], 
           LightBlue, Polygon[(discretPolygon$[[s]] - rc$ - oc$ + #1 & ) /@ 
             robot$]}, {Black, Point[(discretPolygon$[[s]] - rc$ - oc$ + 
               #1 & ) /@ robot$]}, {Red, Point[discretPolygon$[[s]] - oc$]}, 
          {Black, Text["Robot", discretPolygon$[[s]] - oc$ + 
             {0.2, 0.2}]}}}]}]], {{stableOrMove, "Stationary", "View"}, 
   {"Stationary", "Move around Mikowski"}}, 
  {step, 0.01, ControlType -> None}, {{rl, 5}, Dynamic[ol], 
   ControlType -> None}, {{ol, 5}, ControlType -> None}, 
  {{a, True, "Normals"}, {True, False}, ControlPlacement -> 1}, 
  {{c, True, "Locators"}, {True, False}, ControlPlacement -> 2}, 
  {{m, 5, "Robot Edges"}, {1, 2, 3, 4, 5}, ControlPlacement -> 3}, 
  {{n, 5, "Obstacle Edges"}, {1, 2, 3, 4, 5}, ControlPlacement -> 4}, 
  {{s, 1, "Move"}, 1, Dynamic[(rl + ol)*(1/step) - (rl + ol - 1)], 1, 
   AnimationRunning -> True, Appearance -> "Open", ControlPlacement -> 5}, 
  Dynamic[If[stableOrMove != "Move around Mikowski", 
    Row[{Manipulate`Place[1], Manipulate`Place[2], Manipulate`Place[3], 
      Manipulate`Place[4]}, "  "], Manipulate`Place[5]]], 
  {{pts, {{2.885, 1.489}, {3.249, 2.6}, {2.298, 3.298}, {1.348, 2.607}, 
     {1.71, 1.489}, {-1.71, 1.489}, {-1.34704, 2.607}, {-2.298, 3.298}, 
     {-3.249, 2.607}, {-2.885, 1.489}}}, {-3.249, 1.489}, {3.249, 3.298}, 
   ControlType -> Locator, Appearance -> None, Enabled -> Dynamic[c]}, 
  AppearanceElements -> {}, PreserveImageOptions -> True]

ISSUES
//1) Color the α's  and β's  blue and red in Minkowski region.
//1) Point and Line Minkowski fix.
//3)when one vertex of the triangle is translated to other direction, the normals reverse the directions.
1) Minkowski Shifting when changing some locators in robot/ obstacle. (Very Important)
2)when robot/obstacle is a Line we get 2 normals both opposite to each other.
3) Make new Minkowski Function with new changes.
4)Make demo by tomorrow. writeup the demonstration text (summary, details, related work, etc.)